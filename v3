#include <bits/stdc++.h>
#include <iostream>
#include <pthread.h>
#include <semaphore.h>
// #include <stdio.h>
// #include <stdlib.h>
// #include <unistd.h>
using namespace std;

// #include <fstream>
// #include <iomanip>
// #include <vector>
// #include <algorithm>
// #include <iostream>
// using namespace std;

sem_t semaphore;
sem_t semaphore2;
pthread_mutex_t mutex1;
pthread_mutex_t mutex2;

pthread_barrier_t barrier;

int id_th;

struct th {
    int id;
	int map_threads;
	int reduce_threads;
	vector<vector<int>> l;
	char filename[20];
	//int l[20][20];
};

void *f_reduce(void *arg)
{
	//pthread_barrier_wait(&barrier);
	//sem_post(&semaphore2);
	
	sem_wait(&semaphore2);
	// sem_post(&semaphore2);
	puts("In f_reduce++++++++++++++++++++++");

	pthread_exit(NULL);
}

void *f_map(void *arg) {

	sem_wait(&semaphore2);
    struct th *t = (struct th*) arg;
	cout <<"ID_UL ESTE : [" << t->id << "]" << endl;
	//if (t->id < t->map_threads) {
	FILE* fp2;
	int r, nr;

	fp2 = fopen(t->filename, "r"); 
	cout << t->filename << endl;
	if(fp2 == NULL)
	{
		printf("Error!");   
		exit(1);             
	}
	fscanf(fp2, "%d", &r);
	printf(" r =  %d: ", r);
	//PRELUCREZ VALORILE DIN FISERE
	for (int k = 0; k < r; k++){
		fscanf(fp2, "%d", &nr);
		printf(" %d", nr);
		// for (int i = 2; i < nr/2; i++){
		// 	for (int p = 2; p <= t->reduce_threads + 1; p++){
		// 		if (pow(i,k) == nr) {
		// 			t->l[k-2] = nr;
		// 		}
		// 	}
		// }
		if (nr == 1){
			for (int p = 2; p <= t->reduce_threads + 1; p++){
				t->l[p-2].push_back(nr);
			}
		}
		else
		{
		
			for (int p = 2; p <= t->reduce_threads + 1; p++){
				for (int i = 2; i < nr/2; i++){
					if (pow(i,p) == nr){
						t->l[p-2].push_back(nr);
						break; //trec la puterea urmat
					}
					else if(pow(i,p) > nr){
						break;
					}
				}
			}
		}
	}
	puts("");
	fclose(fp2);

    printf("id = %d, map_threads = %d, reduce_threads = %d\n", t->id, t->map_threads, t->reduce_threads);

	pthread_mutex_lock(&mutex1);
	id_th = t->id;
	pthread_mutex_unlock(&mutex1);
	//sem_wait(&semaphore2);
	//sem_post(&semaphore);
	//sem_wait(&semaphore2);
	//-----------------------------------------
	//as putea incepe de aici de prelucrat noul fisier???
	//} //end of map threads
	// else {
	// 	// problema e cand folosesc sem_post !!!!!!!!!!!!
	// 	sem_wait(&semaphore2);
	// 	puts("In f_reduce++++++++++++++++++++++");
	// }
	pthread_exit(NULL);
    
}


int main(int argc, char **argv)
{
	//de facut static pt testare fara argumente
	//int map_threads = atoi(argv[1]);
	int map_threads = 4; //de comentaty !!!!!!!!!!!!!!!!
	//int reduce_threads = atoi(argv[2]);
	int reduce_threads = 5;
	int cores = map_threads + reduce_threads;
	int ids[cores];
	int N, i, r, nr;
	char s[20];
	int a = 0, a2 = -100;
	int barrier_no= 10;
	FILE *fp;
	pthread_t threads[cores];
	sem_init(&semaphore, 0, a);
	sem_init(&semaphore2, 0, 4);
	r = pthread_mutex_init(&mutex1, NULL);
	if (r != 0) {
		printf("ERR");
		exit(0);
	}

	r = pthread_mutex_init(&mutex2, NULL);
	if (r != 0) {
		printf("ERR");
		exit(0);
	}
	
	

	r = pthread_barrier_init(&barrier, NULL, barrier_no);
	if (r != 0) {
		printf("ERR");
		exit(0);
	}

	printf("map_threads = %d, reduce_threads = %d\n", map_threads, reduce_threads);

	//fp = fopen(argv[3], "r");
	fp = fopen("test.txt", "r");

	if(fp == NULL)
	{
		printf("Error!");   
		exit(1);             
	}

	fscanf(fp, "%d", &N);
	printf("N = %d\n", N);
	

	cout << "-----------\n";
	r = 0;


	struct th *t = (struct th*)malloc(sizeof(struct th)*cores);

	int id;

	pthread_mutex_lock(&mutex2);
	for (id = 0; id < map_threads; id++){ // fiecare a primit un fisier
		fscanf(fp, "%s", s);  //citesc in s numele fisierului de pe fiecare linie
		// printf("s = %s", s);
		// puts("");

		ids[id] = id;
		t[id].id = id;
		t[id].map_threads = map_threads;
		t[id].reduce_threads = reduce_threads;
		if (id < map_threads) {
			t[id].l.resize(reduce_threads);
			strcpy(t[id].filename, s);
		}
		//cout << t[id].filename << endl;
		//printf("id = %d, map_threads = %d, reduce_threads = %d\n", t[id].id, t[id].map_threads, t[id].reduce_threads);

		r = pthread_create(&threads[id], NULL, f_map, &t[id]);

		if (r) {
			printf("Eroare la crearea thread-ului %d\n", id);
			exit(-1);
		}
	}

	//asta treb sa inceapa cand termina un thread de tip map
	for (int i = 0; i < N - map_threads; i++){
		//sem_wait(&semaphore);
		fscanf(fp, "%s", s);
		//sem_wait(&semaphore);
		strcpy(t[id_th].filename, s);
		r = pthread_create(&threads[id_th], NULL, f_map, &t[id_th]); //ruleaza in paralel
		if (r) {
			printf("Eroare la crearea thread-ului %d\n", id);
			exit(-1);
		}
	}
	pthread_mutex_unlock(&mutex2);

	//URMEAZA DE COMBINAT VALORILE IN LISTE COMUNE DE FIECARE PUTERE + AFIARE IN FISIERLE DE IESIRE CU REDUCE THREADS
	pthread_mutex_lock(&mutex2);
	for (id = map_threads; id < cores; id++) {
		ids[id] = id;
		t[id].id = id;
		t[id].map_threads = map_threads;
		t[id].reduce_threads = reduce_threads;
		//t[id].l.resize(reduce_threads);
		
		r = pthread_create(&threads[id], NULL, f_reduce, &t[id]);

		if (r) {
			printf("Eroare la crearea thread-ului %d\n", id);
			exit(-1);
		}

	}
	pthread_mutex_unlock(&mutex2);
	//pthread_barrier_wait(&barrier); 
	//TREBUIE sa fac wait.ul in fctia f!!!!!!!!!!!! doar acolo are efect deci am nev de semaphor pt map threads pe care il folosesc in thread.urile reduce 
	//pt a sti dc sa continui rularea lor sau nu cu swm_wait() 
	cout << "A este: " <<a2 << endl;
	//sem_wait(&semaphore2);
	puts("LISTELE FORMATE");
	int kol = 2;
	// for (id = 0; id < map_threads; id++){
	// 	kol = 2;
	// 	for (const auto&i : t[id].l){
	// 		cout << kol++ <<": ";
	// 		for (int k : i){
	// 			cout << k << ' ';
	// 		}
	// 		cout << endl;
	// 	}
	// 	cout << endl;
	// }


	for (i = 0; i < cores; i++) { // folosesc doar mpa_threads inca, dar la final o sa le folosesc pe ambele adica si reduce si o sa ma cores
		r = pthread_join(threads[i], NULL);

		if (r) {
			printf("Eroare la asteptarea thread-ului %d\n", i);
			exit(-1);
		}
	}
	

	fclose(fp);
	pthread_mutex_destroy(&mutex1);
	sem_destroy(&semaphore);
	sem_destroy(&semaphore2);

	pthread_barrier_destroy(&barrier);
	
	/* code */
	return 0;
}
