Oprea Mihail 334CC
Tema1 apd
	Mai intai in main mi-am luat in var int map_threads, reduce_threads nr. de thread-uri de tip map respectiv reduce din argumentele primite in linia de comanda.
	Am deschis fisierul primit la argv[3] in FILE *fp si am salvat in var int N nr de fisiere de prelucrat.
	Mi-am creat si alocat un array de structuri th pt fiecare thread de tip map, in care imi stochez id-ul thread-ului, nr. de thread-uri map si reduce, N-ul, numele fiserului pe care trebuie sa-l prelucreze un thread de tip map, o var numita int putere si un vector de
vectori pe post de lista pt fiecare lista corespunzatoare unei puteri.
	Dupa trimit in executie thread-urile de tip map cu functia f_map. La inceput fiecarui thread fiindu-i alocat un fisier. Dupa ce primeste fiecare un fisier inseamna ca mai sunt inca N-map_thread fisiere de prelucrat, care se aloca primuli thread care termina si tot asa cum am for-ul de la linia xxx. Aici am un while(a == 1) inauntrul caruia se asteapta sa se elibereze un thread de tip map ca sa
il trimita in executie cu alt nume de fisier din cele ramase prin facerea var int ok 1, unde ok e var globala cu ok = 0. Id-ul thread-ului pe care trebuie sa-l trimita in executie este dat de var int id_th care-i globala si modificata in fct. f_map.
	In functia void *f_map(void *arg) primesc structura corespunzatoare cu id-ului thread-ului, dupa care citesc fisierul stocat in ea si incep sa parcurg valorile din fisier si sa vad care respecta conditia de a fi un nr. la o putere 2 pana la nr. de threaduri reduce + 1 si o stochez in lista care retine numerele la o putere anumita.
	Tot aici am o variabila globala int pass = 0 blocata cu un mutex mutex2 pe care o cresc de fiecare data cand termina un thread de tip map, iar cand pass ajunge la valoarea N inseamna ca toate valorile din cele N fisiere au fost stocate si dau drumul la semaforul semaphore2 care intial e pe 0.
	In plus in aceasta functie mai am o var globala int ok = 0, care aici e blocata de un mutex mutex2 care divne 1 cand am terminat de prelucrat valorile din fisier, astfel anuntand ca thread-ul acesta poate incepe un nou fisier punandu-si id-ul thread-ului in var global int id_th.
	Punerea in executie a thread-urilor de tip reduce se face cu functia f_reduce in care dau ca argument functiei pt. fiecare thread, to array-ul de structuri pt. ca un thread de tip reduce sa aiba acces la lista specifiaca pt. o anumita putere de la fiecare thread de tip map.
	Aici sem_wait(&semaphore2) va fi 1(eliberat) abia cand pass = N (var descrisa mai sus). Dupa semaforul va ajunge la val 0 si de aceea fac imediat dupa sem_post(&semaphore2) ca celelate thread-uri de tip map sa poata rula relativ in paralel. La final imi strang toate valorile pt. fiecare lista din fiecare structura intr-un set declarat set<int> list_reduce ca apoi sa nr. valorile din set si sa afisez valoare in fisierul corespunzator de iesire. Rolul var. int putere dintr-o structura e folosit doar pt. id-ul 0 unde putere = 1 la inceput, iar de fiecare data isi incepe executia un thread de tip reduce prun apelul fct. void *f_reduce(void *arg) va creste la inceput de functie intre sem_wait si sem_post cu 1 prin t[0].putere++, astfel primul thread care ajunge va lucra cu listele de putere 2, urmatorul cu cele de putere 3 si tot asa.
	La final de tot in main fac join pt thread-uri si distrug mutex-urile si semafoarele folosite.
