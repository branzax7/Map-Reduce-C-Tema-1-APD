#include <bits/stdc++.h>
#include <iostream>
#include <pthread.h>
// #include <stdio.h>
// #include <stdlib.h>
// #include <unistd.h>
using namespace std;

struct th {
    int id;
	int map_threads;
	int reduce_threads;
	vector<vector<int>> l;
	char filename[20];
	//int l[20][20];
};


void *f(void *arg) {

    struct th *t = (struct th*) arg;
	FILE* fp2;
	int r, nr;

	fp2 = fopen(t->filename, "r"); 
	cout << t->filename << endl;
	if(fp2 == NULL)
	{
		printf("Error!");   
		exit(1);             
	}
	fscanf(fp2, "%d", &r);
	printf(" r =  %d: ", r);
	for (int k = 0; k < r; k++){
		fscanf(fp2, "%d", &nr);
		printf(" %d", nr);
	}
	puts("");
	fclose(fp2);

    printf("id = %d, map_threads = %d, reduce_threads = %d\n", t->id, t->map_threads, t->reduce_threads);
	//URMEAZA DE PRELUCRAT VALORILE IN LISTELE DIN STUCT T
    
}

int main(int argc, char **argv)
{
	int map_threads = atoi(argv[1]);
	int reduce_threads = atoi(argv[2]);
	int cores = map_threads + reduce_threads;
	int ids[cores];
	int N, i, r, nr;
	char s[20];

	FILE *fp;
	pthread_t threads[cores];
	printf("map_threads = %d, reduce_threads = %d\n", map_threads, reduce_threads);

	fp = fopen(argv[3], "r");

	if(fp == NULL)
	{
		printf("Error!");   
		exit(1);             
	}

	fscanf(fp, "%d", &N);
	printf("N = %d\n", N);
	// for (int i = 0; i < N; i++) {
	// 	fscanf(fp, "%s", s);
	// 	printf("s = %s", s);

	// 	fp2 = fopen(s, "r"); 
	// 	if(fp2 == NULL)
	// 	{
	// 		printf("Error!");   
	// 		exit(1);             
	// 	}
	// 	fscanf(fp2, "%d", &r);
	// 	printf(" r =  %d: ", r);
	// 	for (int k = 0; k < r; k++){
	// 		fscanf(fp2, "%d", &nr);
	// 		printf(" %d", nr);
	// 	}
	// 	puts("");


	// 	fclose(fp2);
	// }
	// puts("");

	

	cout << "-----------\n";
	r = 0;
	vector<vector<int>> dp;
	dp.resize(3);
	for (int i = 0; i < 4; i++){
		for (int j = 0; j < 5; j++)
			dp[i].push_back(r++);
	}

	for (int l = 0; l < (int)dp.size(); l++){
		for (int i : dp[l]) {
			cout << i << " ";
		}
		cout << endl;
	}
	cout << "-----" << endl;


	struct th *t = (struct th*)malloc(sizeof(struct th)*map_threads);

	int id;

	for (id = 0; id < map_threads; id++){
		fscanf(fp, "%s", s);
		// printf("s = %s", s);
		// puts("");

		//ids[i] = i;
		t[id].id = id;
		t[id].map_threads = map_threads;
		t[id].reduce_threads = reduce_threads;
		t[id].l.resize(reduce_threads);
		strcpy(t[id].filename, s);
		//cout << t[id].filename << endl;
		//printf("id = %d, map_threads = %d, reduce_threads = %d\n", t[id].id, t[id].map_threads, t[id].reduce_threads);

		r = pthread_create(&threads[id], NULL, f, &t[id]);

		if (r) {
			printf("Eroare la crearea thread-ului %d\n", id);
			exit(-1);
		}
	}


	for (i = 0; i < map_threads; i++) { // folosesc doar mpa_threads inca, dar la final o sa le folosesc pe ambele adica si reduce si o sa ma cores
		r = pthread_join(threads[i], NULL);

		if (r) {
			printf("Eroare la asteptarea thread-ului %d\n", i);
			exit(-1);
		}
	}

	fclose(fp);
	
	/* code */
	return 0;
}
