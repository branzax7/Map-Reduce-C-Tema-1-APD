#include <bits/stdc++.h>
#include <iostream>
#include <pthread.h>
#include <semaphore.h>
// #include <stdio.h>
// #include <stdlib.h>
// #include <unistd.h>
using namespace std;

// #include <fstream>
// #include <iomanip>
// #include <vector>
// #include <algorithm>
// #include <iostream>
// using namespace std;

sem_t semaphore;
pthread_mutex_t mutex1;

int id_th;

struct th {
    int id;
	int map_threads;
	int reduce_threads;
	vector<vector<int>> l;
	char filename[20];
	//int l[20][20];
};


void *f(void *arg) {

    struct th *t = (struct th*) arg;
	FILE* fp2;
	int r, nr;

	fp2 = fopen(t->filename, "r"); 
	cout << t->filename << endl;
	if(fp2 == NULL)
	{
		printf("Error!");   
		exit(1);             
	}
	fscanf(fp2, "%d", &r);
	printf(" r =  %d: ", r);
	//PRELUCREZ VALORILE DIN FISERE
	for (int k = 0; k < r; k++){
		fscanf(fp2, "%d", &nr);
		printf(" %d", nr);
		// for (int i = 2; i < nr/2; i++){
		// 	for (int p = 2; p <= t->reduce_threads + 1; p++){
		// 		if (pow(i,k) == nr) {
		// 			t->l[k-2] = nr;
		// 		}
		// 	}
		// }
		if (nr == 1){
			for (int p = 2; p <= t->reduce_threads + 1; p++){
				t->l[p-2].push_back(nr);
			}
		}
		else
		{
		
			for (int p = 2; p <= t->reduce_threads + 1; p++){
				for (int i = 2; i < nr/2; i++){
					if (pow(i,p) == nr){
						t->l[p-2].push_back(nr);
						break; //trec la puterea urmat
					}
					else if(pow(i,p) > nr){
						break;
					}
				}
			}
		}
	}
	puts("");
	fclose(fp2);

    printf("id = %d, map_threads = %d, reduce_threads = %d\n", t->id, t->map_threads, t->reduce_threads);

	pthread_mutex_lock(&mutex1);
	id_th = t->id;
	pthread_mutex_unlock(&mutex1);
	sem_post(&semaphore);
	
    
}


int main(int argc, char **argv)
{
	int map_threads = atoi(argv[1]);
	//map_threads = 2; //de comentaty !!!!!!!!!!!!!!!!
	int reduce_threads = atoi(argv[2]);
	int cores = map_threads + reduce_threads;
	int ids[cores];
	int N, i, r, nr;
	char s[20];
	int a = 0;
	FILE *fp;
	pthread_t threads[cores];
	sem_init(&semaphore, 0, a);
	r = pthread_mutex_init(&mutex1, NULL);
	if (r != 0) {
		printf("ERR");
		exit(0);
	}

	printf("map_threads = %d, reduce_threads = %d\n", map_threads, reduce_threads);

	fp = fopen(argv[3], "r");

	if(fp == NULL)
	{
		printf("Error!");   
		exit(1);             
	}

	fscanf(fp, "%d", &N);
	printf("N = %d\n", N);
	

	cout << "-----------\n";
	r = 0;


	struct th *t = (struct th*)malloc(sizeof(struct th)*map_threads);

	int id;

	for (id = 0; id < map_threads; id++){ // fiecare a primit un fisier
		fscanf(fp, "%s", s);
		// printf("s = %s", s);
		// puts("");

		//ids[i] = i;
		t[id].id = id;
		t[id].map_threads = map_threads;
		t[id].reduce_threads = reduce_threads;
		t[id].l.resize(reduce_threads);
		strcpy(t[id].filename, s);
		//cout << t[id].filename << endl;
		//printf("id = %d, map_threads = %d, reduce_threads = %d\n", t[id].id, t[id].map_threads, t[id].reduce_threads);

		r = pthread_create(&threads[id], NULL, f, &t[id]);

		if (r) {
			printf("Eroare la crearea thread-ului %d\n", id);
			exit(-1);
		}
	}

	for (int i = 0; i < N - map_threads; i++){
		sem_wait(&semaphore);
		fscanf(fp, "%s", s);
		//sem_wait(&semaphore);
		strcpy(t[id_th].filename, s);
		r = pthread_create(&threads[id_th], NULL, f, &t[id_th]);
		if (r) {
			printf("Eroare la crearea thread-ului %d\n", id);
			exit(-1);
		}
	}
	//URMEAZA DE COMBINAT VALORILE IN LISTE COMUNE DE FIECARE PUTERE + AFIARE IN FISIERLE DE IESIRE CU REDUCE THREADS




	for (i = 0; i < map_threads; i++) { // folosesc doar mpa_threads inca, dar la final o sa le folosesc pe ambele adica si reduce si o sa ma cores
		r = pthread_join(threads[i], NULL);

		if (r) {
			printf("Eroare la asteptarea thread-ului %d\n", i);
			exit(-1);
		}
	}

	fclose(fp);
	pthread_mutex_destroy(&mutex1);
	sem_destroy(&semaphore);
	
	/* code */
	return 0;
}
